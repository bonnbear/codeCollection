/**
 * 深度比较两个对象，并找出所有差异。
 * 此版本能够区分【值为 undefined 的属性】和【不存在的属性】。
 *
 * @param {any} obj1 第一个要比较的对象
 * @param {any} obj2 第二个要比较的对象
 * @param {object} [options] 可选配置
 * @param {boolean} [options.compareFunctions=false] 是否比较函数。默认为 false。
 * @returns {{areSame: boolean, differences: Array<{path: string, value1: any, value2: any}>}}
 */
function compareObjects(obj1, obj2, options = {}) {
  const { compareFunctions = false } = options;
  const differences = [];
  const visited = new WeakMap();

  // 使用 Symbol 来唯一地表示一个缺失的属性，避免与任何真实值冲突。
  const MISSING_PROPERTY = Symbol('Missing Property');

  function findDifferences(val1, val2, path = []) {
    if (Object.is(val1, val2)) return;

    // 循环引用检查
    if (typeof val1 === 'object' && val1 !== null) {
      if (visited.has(val1) && visited.get(val1).has(val2)) return;
      if (!visited.has(val1)) visited.set(val1, new WeakSet());
      visited.get(val1).add(val2);
    }

    // 特殊类型处理：函数和日期 (与之前版本相同)
    if (typeof val1 === 'function' && typeof val2 === 'function') {
      if (compareFunctions && val1.toString() !== val2.toString()) {
        differences.push({ path: path.join('.'), value1: 'Function()', value2: 'Function()' });
      }
      return;
    }
    const isDate1 = val1 instanceof Date;
    const isDate2 = val2 instanceof Date;
    if (isDate1 && isDate2) {
      if (val1.getTime() !== val2.getTime()) {
        differences.push({ path: path.join('.'), value1: val1, value2: val2 });
      }
      return;
    }
    
    // 如果类型不同或为原始类型，则记录差异
    if (
      val1 === null || val2 === null ||
      typeof val1 !== 'object' || typeof val2 !== 'object' ||
      Array.isArray(val1) !== Array.isArray(val2) ||
      isDate1 !== isDate2
    ) {
      differences.push({ path: path.join('.'), value1: val1, value2: val2 });
      return;
    }

    // --- 核心修改逻辑在此 ---
    const keys1 = Object.keys(val1);
    const keys2 = Object.keys(val2);
    const allKeys = new Set([...keys1, ...keys2]);

    for (const key of allKeys) {
      const newPath = [...path, key];
      
      // 使用 hasOwnProperty 进行精确的存在性检查
      const hasKey1 = Object.prototype.hasOwnProperty.call(val1, key);
      const hasKey2 = Object.prototype.hasOwnProperty.call(val2, key);

      if (hasKey1 && hasKey2) {
        // 键在两个对象中都存在，递归比较它们的值
        findDifferences(val1[key], val2[key], newPath);
      } else if (hasKey1 && !hasKey2) {
        // 键只在对象1中存在
        differences.push({
          path: newPath.join('.'),
          value1: val1[key],
          value2: MISSING_PROPERTY // 使用 Symbol 表示缺失
        });
      } else { // !hasKey1 && hasKey2
        // 键只在对象2中存在
        differences.push({
          path: newPath.join('.'),
          value1: MISSING_PROPERTY, // 使用 Symbol 表示缺失
          value2: val2[key]
        });
      }
    }
  }

  findDifferences(obj1, obj2);
  
  // 在最终返回结果前，为了方便阅读，可以将 Symbol 转换为字符串描述
  const formattedDifferences = differences.map(diff => ({
    ...diff,
    value1: diff.value1 === MISSING_PROPERTY ? '[Missing Property]' : diff.value1,
    value2: diff.value2 === MISSING_PROPERTY ? '[Missing Property]' : diff.value2,
  }));

  return {
    areSame: differences.length === 0,
    differences: formattedDifferences,
  };
}


// --- 测试示例 ---

const objA = {
  a: 1,
  b: 'hello',
  c: undefined, // 属性存在，值为 undefined
  d: null
};

const objB = {
  a: 1,
  b: 'world',   // 值不同
  // 属性 'c' 在此缺失
  d: undefined, // 值不同 (null vs undefined)
  e: 'extra'    // 新增属性
};

const result = compareObjects(objA, objB);

console.log('--- 区分 undefined 和缺失属性的比较结果 ---');
console.log('是否相同:', result.areSame);
console.log('差异点 (' + result.differences.length + '处):');
result.differences.forEach(diff => {
  // 使用 JSON.stringify 来更清晰地显示 undefined 和 null
  console.log(`
  路径 (Path): ${diff.path}
    - 对象 A 的值: ${JSON.stringify(diff.value1)}
    - 对象 B 的值: ${JSON.stringify(diff.value2)}
  `);
});
