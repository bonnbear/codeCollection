/**
 * 深度比较两个对象，并找出所有差异。
 * 此版本能够区分【值为 undefined 的属性】和【不存在的属性】。
 *
 * @param {any} obj1 第一个要比较的对象
 * @param {any} obj2 第二个要比较的对象
 * @param {object} [options] 可选配置
 * @param {boolean} [options.compareFunctions=false] 是否比较函数。默认为 false。
 * @returns {{areSame: boolean, differences: Array<{path: string, value1: any, value2: any}>}}
 */
function compareObjects(obj1, obj2, options = {}) {
  const { compareFunctions = false } = options;
  const differences = [];
  const visited = new WeakMap();

  // 使用 Symbol 来唯一地表示一个缺失的属性，避免与任何真实值冲突。
  const MISSING_PROPERTY = Symbol('Missing Property');

  function findDifferences(val1, val2, path = []) {
    if (Object.is(val1, val2)) return;

    // 循环引用检查
    if (typeof val1 === 'object' && val1 !== null) {
      if (visited.has(val1) && visited.get(val1).has(val2)) return;
      if (!visited.has(val1)) visited.set(val1, new WeakSet());
      visited.get(val1).add(val2);
    }

    // 特殊类型处理：函数和日期 (与之前版本相同)
    if (typeof val1 === 'function' && typeof val2 === 'function') {
      if (compareFunctions && val1.toString() !== val2.toString()) {
        differences.push({ path: path.join('.'), value1: 'Function()', value2: 'Function()' });
      }
      return;
    }
    const isDate1 = val1 instanceof Date;
    const isDate2 = val2 instanceof Date;
    if (isDate1 && isDate2) {
      if (val1.getTime() !== val2.getTime()) {
        differences.push({ path: path.join('.'), value1: val1, value2: val2 });
      }
      return;
    }
    
    // 如果类型不同或为原始类型，则记录差异
    if (
      val1 === null || val2 === null ||
      typeof val1 !== 'object' || typeof val2 !== 'object' ||
      Array.isArray(val1) !== Array.isArray(val2) ||
      isDate1 !== isDate2
    ) {
      differences.push({ path: path.join('.'), value1: val1, value2: val2 });
      return;
    }

    // --- 核心修改逻辑在此 ---
    const keys1 = Object.keys(val1);
    const keys2 = Object.keys(val2);
    const allKeys = new Set([...keys1, ...keys2]);

    for (const key of allKeys) {
      const newPath = [...path, key];
      
      // 使用 hasOwnProperty 进行精确的存在性检查
      const hasKey1 = Object.prototype.hasOwnProperty.call(val1, key);
      const hasKey2 = Object.prototype.hasOwnProperty.call(val2, key);

      if (hasKey1 && hasKey2) {
        // 键在两个对象中都存在，递归比较它们的值
        findDifferences(val1[key], val2[key], newPath);
      } else if (hasKey1 && !hasKey2) {
        // 键只在对象1中存在
        differences.push({
          path: newPath.join('.'),
          value1: val1[key],
          value2: MISSING_PROPERTY // 使用 Symbol 表示缺失
        });
      } else { // !hasKey1 && hasKey2
        // 键只在对象2中存在
        differences.push({
          path: newPath.join('.'),
          value1: MISSING_PROPERTY, // 使用 Symbol 表示缺失
          value2: val2[key]
        });
      }
    }
  }

  findDifferences(obj1, obj2);
  
  // 在最终返回结果前，为了方便阅读，可以将 Symbol 转换为字符串描述
  const formattedDifferences = differences.map(diff => ({
    ...diff,
    value1: diff.value1 === MISSING_PROPERTY ? '[Missing Property]' : diff.value1,
    value2: diff.value2 === MISSING_PROPERTY ? '[Missing Property]' : diff.value2,
  }));

  return {
    areSame: differences.length === 0,
    differences: formattedDifferences,
  };
}


// --- 测试示例 ---

const objA = {
  a: 1,
  b: 'hello',
  c: undefined, // 属性存在，值为 undefined
  d: null
};

const objB = {
  a: 1,
  b: 'world',   // 值不同
  // 属性 'c' 在此缺失
  d: undefined, // 值不同 (null vs undefined)
  e: 'extra'    // 新增属性
};

const result = compareObjects(objA, objB);

console.log('--- 区分 undefined 和缺失属性的比较结果 ---');
console.log('是否相同:', result.areSame);
console.log('差异点 (' + result.differences.length + '处):');
result.differences.forEach(diff => {
  // 使用 JSON.stringify 来更清晰地显示 undefined 和 null
  console.log(`
  路径 (Path): ${diff.path}
    - 对象 A 的值: ${JSON.stringify(diff.value1)}
    - 对象 B 的值: ${JSON.stringify(diff.value2)}
  `);
});










/**
 * [专家级] 深度比较两个对象，并找出所有差异。
 * 此版本能够处理：
 * - 循环引用
 * - 日期、函数等特殊类型
 * - 区分 `undefined` 和缺失属性
 * - 比较对象的原型（区分普通对象和类实例）
 * - 比较 Symbol 类型的属性
 * - 比较不可枚举的属性
 *
 * @param {any} obj1 第一个要比较的对象
 * @param {any} obj2 第二个要比较的对象
 * @param {object} [options] 可选配置
 * @param {boolean} [options.compareFunctions=false] 是否比较函数。默认为 false。
 * @returns {{areSame: boolean, differences: Array<{path: string, value1: any, value2: any}>}}
 */
function compareObjects(obj1, obj2, options = {}) {
  const { compareFunctions = false } = options;
  const differences = [];
  const visited = new WeakMap();
  const MISSING_PROPERTY = Symbol('Missing Property');

  function findDifferences(val1, val2, path = []) {
    if (Object.is(val1, val2)) return;

    if (typeof val1 === 'object' && val1 !== null) {
      if (visited.has(val1) && visited.get(val1).has(val2)) return;
      if (!visited.has(val1)) visited.set(val1, new WeakSet());
      visited.get(val1).add(val2);
    }

    if (typeof val1 === 'function' && typeof val2 === 'function') {
      if (compareFunctions && val1.toString() !== val2.toString()) {
        differences.push({ path: path.join('.'), value1: 'Function()', value2: 'Function()' });
      }
      return;
    }
    
    const isDate1 = val1 instanceof Date;
    const isDate2 = val2 instanceof Date;
    if (isDate1 && isDate2) {
      if (val1.getTime() !== val2.getTime()) {
        differences.push({ path: path.join('.'), value1: val1, value2: val2 });
      }
      return;
    }

    if (
      val1 === null || val2 === null ||
      typeof val1 !== 'object' || typeof val2 !== 'object' ||
      Array.isArray(val1) !== Array.isArray(val2) ||
      isDate1 !== isDate2
    ) {
      differences.push({ path: path.join('.'), value1: val1, value2: val2 });
      return;
    }
    
    // --- 核心升级：原型检查 ---
    // 如果原型不同，则它们不是同类对象，直接标记为差异。
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
        differences.push({
            path: path.join('.'),
            value1: '[Prototype Mismatch]',
            value2: '[Prototype Mismatch]'
        });
        return;
    }

    // --- 核心升级：使用 Reflect.ownKeys() 获取所有类型的键 ---
    const keys1 = Reflect.ownKeys(val1);
    const keys2 = Reflect.ownKeys(val2);
    const allKeys = new Set([...keys1, ...keys2]);

    for (const key of allKeys) {
      // 路径中的 Symbol 会被自动转换为字符串，如 "Symbol(id)"
      const newPath = [...path, key.toString()];
      
      const hasKey1 = Object.prototype.hasOwnProperty.call(val1, key);
      const hasKey2 = Object.prototype.hasOwnProperty.call(val2, key);

      if (hasKey1 && hasKey2) {
        findDifferences(val1[key], val2[key], newPath);
      } else if (hasKey1 && !hasKey2) {
        differences.push({ path: newPath.join('.'), value1: val1[key], value2: MISSING_PROPERTY });
      } else {
        differences.push({ path: newPath.join('.'), value1: MISSING_PROPERTY, value2: val2[key] });
      }
    }
  }

  findDifferences(obj1, obj2);
  
  const formattedDifferences = differences.map(diff => ({
    ...diff,
    value1: diff.value1 === MISSING_PROPERTY ? '[Missing Property]' : diff.value1,
    value2: diff.value2 === MISSING_PROPERTY ? '[Missing Property]' : diff.value2,
  }));

  return { areSame: differences.length === 0, differences: formattedDifferences };
}


// --- 终极测试示例 ---

// 1. 定义一个类
class MyClass {
  constructor(value) {
    this.value = value;
  }
}

// 2. 定义一个 Symbol
const mySymbol = Symbol('id');

// 3. 创建对象 A
const expertObjA = new MyClass(10);
expertObjA.name = 'Object A';
expertObjA[mySymbol] = 'Symbol-A';
// 添加一个不可枚举属性
Object.defineProperty(expertObjA, 'nonEnumProp', {
  value: 'secret A',
  enumerable: false, 
  writable: true,
  configurable: true
});
expertObjA.metadata = Object.create(null); // 无原型的对象
expertObjA.metadata.source = 'A';


// 4. 创建对象 B (与 A 存在多种细微差异)
const expertObjB = new MyClass(10); // 构造函数相同
expertObjB.name = 'Object A';
expertObjB[mySymbol] = 'Symbol-B'; // <-- Symbol 属性值不同
// 不可枚举属性值也不同
Object.defineProperty(expertObjB, 'nonEnumProp', {
  value: 'secret B',
  enumerable: false,
  writable: true,
  configurable: true
});
expertObjB.metadata = {}; // <-- 普通对象，原型不同
expertObjB.metadata.source = 'A';


// 5. 创建对象 C (与 A 的类型就不同)
const expertObjC = {
    value: 10,
    name: 'Object A'
}; // 普通对象，不是 MyClass 的实例


// --- 执行比较 ---

console.log('--- 比较 A 和 B (同类对象，属性不同) ---');
const resultAB = compareObjects(expertObjA, expertObjB);
console.log('是否相同:', resultAB.areSame);
console.log('差异点:');
resultAB.differences.forEach(diff => console.log(`  - ${JSON.stringify(diff, null, 2)}`));

console.log('\n--- 比较 A 和 C (不同类对象) ---');
const resultAC = compareObjects(expertObjA, expertObjC);
console.log('是否相同:', resultAC.areSame);
console.log('差异点:');
resultAC.differences.forEach(diff => console.log(`  - ${JSON.stringify(diff, null, 2)}`));
