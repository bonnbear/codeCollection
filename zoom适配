*Thinking...*

> **Defining the Core Issue**
> 
> I've pinpointed the problem: the `calculateZoom` function needs a complete overhaul. Screen resolution shouldn't be a factor. I am now focused on crafting the correct mathematical logic. This is the crux of the matter.
> 
> 
> **Correcting the Formula**
> 
> I'm now making detailed changes to the code. The objective is to correct `calculateZoom` and fully implement the changes. The `index.html` file is taking shape with the updated calculation. I'm systematically reviewing the `display.html` code to avoid potential scope issues.
> 
> 
> **Implementing the Solution**
> 
> I'm now ready to translate the formulated corrections into code. My plan, derived from the core issue, the formula, and the necessary modifications to the HTML files, is shaping up nicely. The updated JavaScript functions are ready for integration. I'm concentrating on delivering clear and concise code blocks, along with instructions for use.
> 
> 
> **Providing the Code**
> 
> I'm now ready to provide the completed, corrected code. I've identified the core issue, formulated the correct mathematical logic, modified the `index.html` and confirmed the implementation in `display.html`. My next step is to present the HTML and JavaScript code. I will incorporate detailed instructions for utilization and explain the rationale behind the changes.
> 
> 
> **Finalizing the Presentation**
> 
> I'm now ready to present the finalized code and usage instructions. The plan has been fully executed, correcting the zoom calculation and providing clear guidance. The documentation, in Chinese, is prepared, ready to be delivered.
> 
> 
好的，这是为您整合并修正后的完整代码。

我已经将核心的 `calculateZoom` 计算逻辑在**控制台文件 (`index.html`)** 中进行了修正。显示窗口文件 (`display.html`) 的代码是正确的，无需修改，这里一并提供以确保完整性。

### 核心修正解释

主要的改动在于 `index.html` 中的 `calculateZoom` 函数。修正后的逻辑如下：

*   **旧的错误逻辑**：错误地将屏幕的总分辨率（面积）纳入了计算。这导致当窗口被拖到不同分辨率的屏幕上时，元素的缩放比例会受到屏幕大小的影响，从而物理尺寸不一致。
*   **新的正确逻辑**：`targetZoom = baseZoom * (baseDPR / targetDPR)`。这个公式只关心两个屏幕的**设备像素比（DPR）**。它的目标是让元素在不同屏幕上占据相同的物理像素数量，从而确保其物理尺寸（例如用尺子在屏幕上测量的厘米数）保持一致，这与屏幕有多大无关。

---

### 1. 控制台文件 (`index.html`)

这是主控制面板。请将以下代码保存为 `index.html` 文件。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Zoom 自动检测 - 控制台 (已修复)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f0f2f5; color: #333; margin: 0; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 20px 30px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.07); }
        h1, h2 { color: #1a253c; border-bottom: 1px solid #eef2f5; padding-bottom: 10px; }
        .panels { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; }
        .panel { padding: 20px; border: 1px solid #ddd; border-radius: 8px; background: #fdfdff; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px; }
        input { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 16px; box-sizing: border-box; }
        .input-group { display: flex; gap: 10px; }
        .auto-field { background-color: #e9ecef; color: #6c757d; border-color: #ced4da; }
        .result-field { background-color: #e3f2fd; font-weight: bold; color: #0d47a1; }
        .actions { display: flex; justify-content: center; gap: 20px; margin: 25px 0; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 25px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.2s ease; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(118, 75, 162, 0.3); }
        button#reDetectBtn { background: #6c757d; }
        .instructions { background: #fffbe6; border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 20px; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>智能 Zoom 测试台 (已修复)</h1>
        <div class="instructions">
            <p><strong>工作流程：</strong></p>
            <ol>
                <li>点击 <strong>“打开显示窗口”</strong> (请允许弹出窗口)。</li>
                <li>将两个新窗口分别拖到您的双屏上。</li>
                <li>下方的参数将 <strong>自动检测并填充</strong>。</li>
                <li>您只需修改 <strong>“基准设备”的 Zoom 值</strong>，即可实时观察两个窗口中方块的物理大小变化。</li>
                <li>如果移动了窗口，请点击 <strong>“重新检测屏幕参数”</strong>。</li>
            </ol>
        </div>

        <div class="actions">
            <button id="openWindowsBtn">打开显示窗口</button>
            <button id="reDetectBtn">重新检测屏幕参数</button>
        </div>

        <div class="panels">
            <div class="panel">
                <h2>基准设备 (自动检测)</h2>
                <div class="control-group">
                    <label>检测到的分辨率</label>
                    <div class="input-group">
                        <input type="text" id="baseWidth" class="auto-field" readonly>
                        <input type="text" id="baseHeight" class="auto-field" readonly>
                    </div>
                </div>
                <div class="control-group">
                    <label>检测到的 DPR</label>
                    <input type="text" id="baseDPR" class="auto-field" readonly>
                </div>
                <div class="control-group">
                    <label>手动设置 Zoom</label>
                    <input type="number" id="baseZoom" value="1.5" step="0.1">
                </div>
            </div>
            <div class="panel">
                <h2>目标设备 (自动检测)</h2>
                <div class="control-group">
                    <label>检测到的分辨率</label>
                    <div class="input-group">
                        <input type="text" id="targetWidth" class="auto-field" readonly>
                        <input type="text" id="targetHeight" class="auto-field" readonly>
                    </div>
                </div>
                <div class="control-group">
                    <label>检测到的 DPR</label>
                    <input type="text" id="targetDPR" class="auto-field" readonly>
                </div>
                <div class="control-group">
                    <label>计算出的 Zoom (应用值)</label>
                    <input type="text" id="finalZoomResult" class="result-field" readonly>
                </div>
            </div>
        </div>
    </div>

    <script>
        const channel = new BroadcastChannel('zoom_auto_demo_channel_fixed');

        const elements = {
            baseWidth: document.getElementById('baseWidth'),
            baseHeight: document.getElementById('baseHeight'),
            baseDPR: document.getElementById('baseDPR'),
            baseZoom: document.getElementById('baseZoom'),
            targetWidth: document.getElementById('targetWidth'),
            targetHeight: document.getElementById('targetHeight'),
            targetDPR: document.getElementById('targetDPR'),
            finalZoomResult: document.getElementById('finalZoomResult'),
            openWindowsBtn: document.getElementById('openWindowsBtn'),
            reDetectBtn: document.getElementById('reDetectBtn'),
        };

        // ======================= 【已修复的计算函数】 =======================
        /**
         * 计算目标设备的正确 Zoom 值，以确保元素物理尺寸一致。
         * @param {number} baseDPR - 基准设备的 devicePixelRatio。
         * @param {number} baseZoom - 基准设备上用户设置的 zoom 值。
         * @param {number} targetDPR - 目标设备的 devicePixelRatio。
         * @returns {number} - 计算出的、应应用到目标设备的 zoom 值。
         */
        function calculateZoom(baseDPR, baseZoom, targetDPR) {
            // 确保所有输入值都是有效的正数，否则计算无意义。
            if (![baseDPR, baseZoom, targetDPR].every(v => v > 0)) {
                return 0;
            }
            
            // 正确的公式：目标 Zoom = 基准 Zoom * (基准 DPR / 目标 DPR)
            // 这个公式确保了 (baseZoom * baseDPR) = (targetZoom * targetDPR)，
            // 意味着一个固定 CSS 尺寸的元素在两个屏幕上将占据相同的物理像素数量，
            // 从而实现物理尺寸的统一。屏幕的总分辨率（宽度和高度）与此计算无关。
            return baseZoom * (baseDPR / targetDPR);
        }

        function runCalculationAndBroadcast() {
            const base = {
                dpr: parseFloat(elements.baseDPR.value),
                zoom: parseFloat(elements.baseZoom.value),
            };
            const target = {
                dpr: parseFloat(elements.targetDPR.value),
            };

            // 调用修正后的函数，不再需要传递屏幕宽高。
            const finalZoom = calculateZoom(base.dpr, base.zoom, target.dpr);
            elements.finalZoomResult.value = finalZoom > 0 ? finalZoom.toFixed(4) : 'N/A';

            channel.postMessage({
                messageType: 'updateZoom',
                payload: {
                    baseZoom: base.zoom,
                    targetZoom: finalZoom
                }
            });
        }
        // =================================================================

        channel.onmessage = (event) => {
            const { messageType, payload } = event.data;
            if (messageType === 'report') {
                const { windowType, width, height, dpr } = payload;
                if (windowType === 'base') {
                    elements.baseWidth.value = width;
                    elements.baseHeight.value = height;
                    elements.baseDPR.value = dpr;
                } else if (windowType === 'target') {
                    elements.targetWidth.value = width;
                    elements.targetHeight.value = height;
                    elements.targetDPR.value = dpr;
                }
                // 收到任何一个窗口的报告后，都重新计算和广播
                runCalculationAndBroadcast();
            }
        };

        elements.openWindowsBtn.addEventListener('click', () => {
            window.open('display.html?type=base', 'baseWindow', 'width=400,height=300,left=0,top=0,resizable=yes');
            window.open('display.html?type=target', 'targetWindow', 'width=400,height=300,left=450,top=0,resizable=yes');
        });

        elements.reDetectBtn.addEventListener('click', () => {
            // 向所有监听者请求报告最新的屏幕参数
            channel.postMessage({ messageType: 'requestReport' });
        });

        elements.baseZoom.addEventListener('input', runCalculationAndBroadcast);
    </script>
</body>
</html>
```

---

### 2. 显示窗口文件 (`display.html`)

这是被控制的、用于显示方块的窗口。它的代码无需修改。请将以下代码保存为 `display.html` 文件，并与 `index.html` 放在同一目录下。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>显示窗口</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .element { width: 150px; height: 150px; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; font-size: 16px; font-family: sans-serif; font-weight: bold; border-radius: 8px; transform-origin: center center; transition: all 0.2s ease-out; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .zoom-value { font-size: 24px; margin-top: 5px; }
        .info { font-size: 12px; position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; color: white; }
        body.base { background-color: #e3f2fd; }
        .base .element { background: #1976d2; }
        body.target { background-color: #e8f5e9; }
        .target .element { background: #2e7d32; }
    </style>
</head>
<body>
    <div class="element">
        <span id="title"></span>
        <span id="zoomValue" class="zoom-value">0.0</span>
    </div>
    <div id="info" class="info"></div>

    <script>
        const channel = new BroadcastChannel('zoom_auto_demo_channel_fixed');
        const element = document.querySelector('.element');
        const titleEl = document.getElementById('title');
        const zoomValueEl = document.getElementById('zoomValue');
        const infoEl = document.getElementById('info');

        // 从URL获取此窗口的类型 ('base' 或 'target')
        const windowType = new URLSearchParams(window.location.search).get('type');

        function detectAndReport() {
            // 注意：window.screen.width/height 返回的是CSS像素（逻辑像素）
            const screenInfo = {
                width: window.screen.width,
                height: window.screen.height,
                dpr: window.devicePixelRatio
            };
            
            // 发送报告给控制台
            channel.postMessage({
                messageType: 'report',
                payload: {
                    windowType: windowType,
                    ...screenInfo
                }
            });
            
            infoEl.innerHTML = `检测到: ${screenInfo.width}x${screenInfo.height} @${screenInfo.dpr}x`;
        }

        // 监听来自控制台的消息
        channel.onmessage = (event) => {
            const { messageType, payload } = event.data;

            if (messageType === 'updateZoom') {
                let zoomToApply = 0;
                // 根据自己的窗口类型，应用对应的 zoom 值
                if (windowType === 'base') {
                    zoomToApply = payload.baseZoom;
                } else if (windowType === 'target') {
                    zoomToApply = payload.targetZoom;
                }
                
                element.style.zoom = zoomToApply;
                zoomValueEl.textContent = zoomToApply > 0 ? zoomToApply.toFixed(4) : 'N/A';

            } else if (messageType === 'requestReport') {
                // 当控制台请求时，重新检测并报告
                detectAndReport();
            }
        };

        // 初始化窗口样式和标题
        if (windowType === 'base') {
            document.body.classList.add('base');
            document.title = '基准设备窗口';
            titleEl.textContent = '基准设备';
        } else if (windowType === 'target') {
            document.body.classList.add('target');
            document.title = '目标设备窗口';
            titleEl.textContent = '目标设备';
        }

        // 窗口加载时立即进行一次检测和报告
        window.addEventListener('load', detectAndReport);
    </script>
</body>
</html>
```

### 如何使用

1.  将上述两个代码块分别保存为 `index.html` 和 `display.html` 文件。
2.  确保这两个文件位于同一个文件夹中。
3.  用浏览器打开 `index.html` 文件。
4.  按照页面上的指示操作即可。现在，当您拖动窗口到不同DPR的屏幕并点击“重新检测”后，两个方块的物理大小应该会保持一致了。
