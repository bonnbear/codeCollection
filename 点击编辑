<template>
  <el-form ref="formRef" :model="formData" :rules="rules">
    <el-table ref="tableRef" :data="tableData" style="width: 100%" @cell-click="handleCellClick">
      <el-table-column v-for="column in columns" :key="column.prop" :label="column.label" :width="column.width">
        <template #default="scope">
          <el-form-item 
            :prop="`rows.${scope.$index}.${column.prop}.value`"
            :rules="rules[column.prop]"
            :class="{ 'is-error': showError(scope.$index, column.prop) }"
          >
            <span 
              v-if="!isEditing(scope.row, column.prop)" 
              @click.stop="startEdit(scope.row, column.prop, scope.$index)"
              :class="{ 'is-required': isRequired(column.prop) }"
            >
              {{ formatCellValue(scope.row[column.prop].value, column.type, column.options) }}
            </span>
            <!-- 输入框 -->
            <el-input
              v-else-if="column.type === 'input'"
              v-model="scope.row[column.prop].value"
              @blur="finishEdit"
              @keyup.enter="finishEdit"
              ref="inputRefs"
            />
            <!-- 选择器 -->
            <el-select
              v-else-if="column.type === 'select'"
              v-model="scope.row[column.prop].value"
              @blur="finishEdit"
              @change="finishEdit"
              ref="inputRefs"
              style="width: 100%"
            >
              <el-option
                v-for="item in column.options"
                :key="item.value"
                :label="item.label"
                :value="item.value"
              />
            </el-select>
            <!-- 日期选择器 -->
            <el-date-picker
              v-else-if="column.type === 'date'"
              v-model="scope.row[column.prop].value"
              :type="column.dateType || 'date'"
              :format="column.format"
              :value-format="column.valueFormat || 'YYYY-MM-DD'"
              @blur="finishEdit"
              @change="finishEdit"
              ref="inputRefs"
              style="width: 100%"
            />
            <!-- 数字输入框 -->
            <el-input-number
              v-else-if="column.type === 'number'"
              v-model="scope.row[column.prop].value"
              :min="column.min"
              :max="column.max"
              :precision="column.precision"
              :step="column.step || 1"
              @blur="finishEdit"
              @change="finishEdit"
              ref="inputRefs"
              style="width: 100%"
            />
            <!-- 开关 -->
            <el-switch
              v-else-if="column.type === 'switch'"
              v-model="scope.row[column.prop].value"
              @change="finishEdit"
              ref="inputRefs"
            />
          </el-form-item>
        </template>
      </el-table-column>
    </el-table>
  </el-form>
</template>

<script setup>
import { ref, reactive, nextTick, onMounted, onUnmounted } from 'vue'
import { ElTable, ElTableColumn, ElInput, ElForm, ElFormItem, ElSelect, ElOption, ElDatePicker, ElInputNumber, ElSwitch } from 'element-plus'

// 列配置
const columns = [
  { 
    prop: 'date', 
    label: '日期', 
    width: '180', 
    required: true,
    type: 'date',
    format: 'YYYY-MM-DD',
    valueFormat: 'YYYY-MM-DD'
  },
  { 
    prop: 'name', 
    label: '姓名', 
    width: '180', 
    required: true,
    type: 'input'
  },
  { 
    prop: 'type', 
    label: '类型', 
    width: '180',
    required: true,
    type: 'select',
    options: [
      { value: '1', label: '类型一' },
      { value: '2', label: '类型二' },
      { value: '3', label: '类型三' }
    ]
  },
  { 
    prop: 'amount', 
    label: '金额', 
    width: '180',
    type: 'number',
    required: true,
    min: 0,
    max: 1000000,
    precision: 2,
    step: 0.1
  },
  { 
    prop: 'status', 
    label: '状态', 
    width: '100',
    type: 'switch'
  },
  { 
    prop: 'address', 
    label: '地址',
    type: 'input'
  }
]

const createEditableCell = (value) => reactive({
  value,
  isEditing: false
})

const tableData = ref([
  {
    date: createEditableCell('2016-05-03'),
    name: createEditableCell('张三'),
    type: createEditableCell('1'),
    amount: createEditableCell(100),
    status: createEditableCell(true),
    address: createEditableCell('浙江省杭州市西湖区')
  },
  {
    date: createEditableCell('2016-05-02'),
    name: createEditableCell('李四'),
    type: createEditableCell('2'),
    amount: createEditableCell(200),
    status: createEditableCell(false),
    address: createEditableCell('广东省深圳市南山区')
  }
])

// 表单数据模型
const formData = reactive({
  rows: tableData.value
})

// 验证规则
const rules = {
  date: [
    { required: true, message: '日期不能为空', trigger: 'change' }
  ],
  name: [
    { required: true, message: '姓名不能为空', trigger: 'blur' },
    { min: 2, max: 5, message: '长度在 2 到 5 个字符', trigger: 'blur' }
  ],
  type: [
    { required: true, message: '请选择类型', trigger: 'change' }
  ],
  amount: [
    { required: true, message: '请输入金额', trigger: 'change' },
    { type: 'number', min: 0, max: 1000000, message: '金额必须在0-1000000之间', trigger: 'change' }
  ]
}

const formatCellValue = (value, type, options) => {
  if (value === null || value === undefined) return ''
  
  switch (type) {
    case 'select':
      return options?.find(opt => opt.value === value)?.label || value
    case 'switch':
      return value ? '是' : '否'
    default:
      return value
  }
}

const formRef = ref(null)
const inputRefs = ref([])
const currentEditingCell = ref(null)
const tableRef = ref(null)

const isRequired = (prop) => {
  return columns.find(col => col.prop === prop)?.required
}

const showError = (index, prop) => {
  const errors = formRef.value?.errors
  const fieldName = `rows.${index}.${prop}.value`
  return errors && errors[fieldName]
}

const isEditing = (row, prop) => {
  return currentEditingCell.value && 
         currentEditingCell.value.row === row && 
         currentEditingCell.value.prop === prop
}

// 修改点 1：修改 startEdit 函数，增加对当前编辑单元格的判断
const startEdit = (row, prop, index) => {
  const column = columns.find(col => col.prop === prop)
  // 如果是开关类型，直接切换值而不进入编辑状态
  if (column.type === 'switch') {
    row[prop].value = !row[prop].value
    return
  }

  // 如果已经在编辑这个单元格，则不需要重新进入编辑状态
  if (currentEditingCell.value &&
      currentEditingCell.value.row === row && 
      currentEditingCell.value.prop === prop) {
    return
  }

  if (currentEditingCell.value) {
    finishEdit()
  }
  
  currentEditingCell.value = { row, prop, index }
  nextTick(() => {
    const input = inputRefs.value.find(el => el && el.$el.contains(document.activeElement))
    if (input) {
      input.focus()
    }
  })
}

const finishEdit = async () => {
  if (currentEditingCell.value) {
    const { index, prop } = currentEditingCell.value
    try {
      await formRef.value?.validateField(`rows.${index}.${prop}.value`)
      currentEditingCell.value = null
    } catch (error) {
      return
    }
  }
}

// 修改点 2：修改 handleCellClick 函数，增加对当前编辑单元格的判断
const handleCellClick = (row, column, cell, event) => {
  // 如果点击的是当前正在编辑的单元格，则不做任何处理
  if (currentEditingCell.value && 
      currentEditingCell.value.row === row && 
      currentEditingCell.value.prop === column.property) {
    return
  }
  
  // 如果点击的是其他单元格，则完成当前编辑并开始新的编辑
  if (currentEditingCell.value) {
    finishEdit()
  }
}

const handleGlobalClick = (event) => {
  if (currentEditingCell.value && tableRef.value) {
    const tableEl = tableRef.value.$el
    if (tableEl && !tableEl.contains(event.target)) {
      finishEdit()
    }
  }
}

onMounted(() => {
  nextTick(() => {
    document.addEventListener('click', handleGlobalClick)
  })
})

onUnmounted(() => {
  document.removeEventListener('click', handleGlobalClick)
})

// 验证整个表格数据的方法
const validateTable = () => {
  return formRef.value.validate()
}
</script>

<style scoped>
.el-table .cell {
  line-height: 23px;
}

.is-required:not(.el-form-item--error):before {
  content: "*";
  color: #f56c6c;
  margin-right: 4px;
}

.el-form-item.is-error {
  margin-bottom: 0;
}

.el-form-item.is-error .el-input__wrapper,
.el-form-item.is-error .el-select .el-input__wrapper,
.el-form-item.is-error .el-date-editor.el-input__wrapper {
  box-shadow: 0 0 0 1px #f56c6c inset;
}

:deep(.el-select .el-input__wrapper) {
  width: 100%;
}

:deep(.el-date-editor.el-input__wrapper) {
  width: 100%;
}

:deep(.el-input-number .el-input__wrapper) {
  box-shadow: none;
}
</style>
