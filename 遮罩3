<template>
  <div id="app">
    <!-- Top Buttons -->
    <div v-if="editMode" class="top-buttons">
      <button @click="saveLayout" class="save-button">保存</button>
      <button @click="addItem" class="add-button">添加</button>
      <button @click="toggleEditMode" class="mode-button">
        切换到查看模式
      </button>
    </div>

    <!-- Title -->
    <h1 class="title">Vue 网格布局</h1>

    <!-- Layout JSON Display -->
    <div class="layoutJSON">
      <h2>布局详情 <code>[x, y, w, h]</code>:</h2>
      <div class="columns">
        <div class="layoutItem" v-for="item in layout" :key="item.i">
          <b>{{ item.i }}</b
          >: [{{ item.x }}, {{ item.y }}, {{ item.w }}, {{ item.h }}]
        </div>
      </div>
    </div>

    <!-- Content Area -->
    <div id="content" :class="{ 'view-mode': !editMode }">
      <!-- Control Buttons -->
      <div class="control-buttons" v-if="editMode">
        <button @click="decreaseWidth">减小宽度</button>
        <button @click="increaseWidth">增加宽度</button>
        <button @click="addItem">添加项目</button>
        <button @click="addItemDynamically">动态添加项目</button>
        <label><input type="checkbox" v-model="draggable" /> 可拖动</label>
        <label><input type="checkbox" v-model="resizable" /> 可调整大小</label>
        <label><input type="checkbox" v-model="mirrored" /> 镜像</label>
        <label><input type="checkbox" v-model="responsive" /> 响应式</label>
        <label
          ><input type="checkbox" v-model="preventCollision" />
          防止碰撞</label
        >
      </div>

      <!-- Grid Settings -->
      <div class="grid-settings" v-if="editMode">
        <label>
          行高:
          <input type="number" v-model="rowHeight" />
        </label>
        <label>
          列数:
          <input type="number" v-model="colNum" />
        </label>
        <label>
          边距 x:
          <input type="number" v-model="marginX" />
        </label>
        <label>
          边距 y:
          <input type="number" v-model="marginY" />
        </label>
      </div>

      <!-- Grid Layout -->
      <grid-layout
        ref="gridlayout"
        :class="{ 'view-mode': !editMode }"
        :margin="[parseInt(marginX), parseInt(marginY)]"
        :layout="layout"
        :responsive-layouts="layouts"
        :col-num="parseInt(colNum)"
        :row-height="rowHeight"
        :is-draggable="draggable && editMode"
        :is-resizable="resizable && editMode"
        :is-mirrored="mirrored"
        :prevent-collision="preventCollision"
        :vertical-compact="false"
        :use-css-transforms="true"
        :responsive="false"
        @layout-created="layoutCreatedEvent"
        @layout-before-mount="layoutBeforeMountEvent"
        @layout-mounted="layoutMountedEvent"
        @layout-ready="layoutReadyEvent"
        @layout-updated="layoutUpdatedEvent"
        @breakpoint-changed="breakpointChangedEvent"
      >
        <grid-item
          v-for="item in layout"
          :key="item.i"
          :class="{ 'view-mode': !editMode }"
          :static="!editMode || item.static"
          :x="item.x"
          :y="item.y"
          :w="item.w"
          :h="item.h"
          :i="item.i"
          :max-h="item.maxH"
          :min-w="item.minW"
          :max-w="item.maxW"
          :min-x="item.minX"
          :max-x="item.maxX"
          :min-y="item.minY"
          :max-y="item.maxY"
          :preserve-aspect-ratio="item.preserveAspectRatio"
          ref="gridItemRefs"
          @resize="resize"
          @move="move"
          @resized="resized"
          @container-resized="containerResized"
          @moved="moved"
        >
          <component
            class="grid-component"
            :is="item.component"
            :data="item"
            @removeItem="removeItem($event)"
            @expandItem="expandItem"
            :editMode="editMode"
          ></component>
        </grid-item>
      </grid-layout>

      <!-- Draggable Element -->
      <div
        v-if="editMode"
        @dragstart="dragstart"
        @drag="drag"
        @dragend="dragend"
        class="droppable-element"
        draggable="true"
        unselectable="on"
      >
        可拖放元素（拖动我！）
      </div>
    </div>

    <!-- Edit Mode Overlay -->
    <div v-if="!editMode" class="edit-overlay">
      <button @click="toggleEditMode" class="mode-button overlay-button">
        切换到编辑模式
      </button>
    </div>
  </div>
</template>

<script setup>
import {
  ref,
  reactive,
  onMounted,
  nextTick,
  markRaw,
  defineAsyncComponent,
} from "vue";
import IframeComponent from "./components/IframeComponent.vue";

// 模拟API调用获取数据
const fetchLayoutData = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        {
          x: 0,
          y: 0,
          w: 2,
          h: 2,
          i: "0",
          componentName: "TestElement",
          data: { text: "项目 0" },
        },
        {
          x: 2,
          y: 0,
          w: 2,
          h: 4,
          i: "1",
          componentName: "AnotherComponent",
          data: { content: "项目 1" },
        },
        {
          x: 4,
          y: 0,
          w: 2,
          h: 5,
          i: "2",
          componentName: "TestElement",
          data: { text: "项目 2" },
        },
        {
          x: 6,
          y: 0,
          w: 4,
          h: 4,
          i: "3",
          componentName: "https://example.com",
          data: { url: "https://example.com" },
        },
        // 其他初始数据...
      ]);
    }, 500);
  });
};

// 模拟API调用保存数据
const saveLayoutData = (layout) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("保存布局数据:", layout);
      resolve();
    }, 500);
  });
};

const layouts = reactive({ lg: [] });
const layout = ref(layouts["lg"]);
const draggable = ref(true);
const resizable = ref(true);
const mirrored = ref(false);
const responsive = ref(true);
const preventCollision = ref(false);
const rowHeight = ref(40);
const colNum = ref(24);
const index = ref(0);
const marginX = ref(10);
const marginY = ref(10);
const mouseXY = reactive({ x: null, y: null });
const DragPos = reactive({ x: null, y: null, w: 1, h: 1, i: null });
const gridItemRefs = ref([]);
const editMode = ref(true);
const gridlayout = ref(null);

const expandItem = ({ i, w, h }) => {
  const idx = layout.value.findIndex((item) => item.i === i);
  if (idx !== -1) {
    layout.value[idx].w = w;
    layout.value[idx].h = h;

    // 触发布局更新
    nextTick(() => {
      if (gridlayout.value) {
        gridlayout.value.layoutUpdate();
      }
    });
  }
};

const importComponent = (componentName) => {
  if (
    componentName.startsWith("http://") ||
    componentName.startsWith("https://")
  ) {
    return markRaw(IframeComponent);
  } else {
    return defineAsyncComponent(() =>
      import(`./components/${componentName}.vue`)
    );
  }
};

onMounted(async () => {
  // 获取初始布局数据
  const initialData = await fetchLayoutData();
  layout.value = await Promise.all(
    initialData.map(async (item) => {
      const component = await importComponent(item.componentName);
      return {
        ...item,
        component: markRaw(component),
      };
    })
  );
  index.value = layout.value.length;

  // 添加拖动事件监听
  document.addEventListener(
    "dragover",
    (e) => {
      mouseXY.x = e.clientX;
      mouseXY.y = e.clientY;
    },
    false
  );
});

const increaseWidth = () => {
  let width = document.getElementById("content").offsetWidth;
  width += 20;
  document.getElementById("content").style.width = width + "px";
};

const decreaseWidth = () => {
  let width = document.getElementById("content").offsetWidth;
  width -= 20;
  document.getElementById("content").style.width = width + "px";
};

const removeItem = (i) => {
  const idx = layout.value.map((item) => item.i).indexOf(i);
  layout.value.splice(idx, 1);
};

const addItem = () => {
  let item = {
    x: 0,
    y: 0,
    w: 2,
    h: 2,
    i: index.value + "",
    componentName: "TestElement",
    data: { text: "新项目" },
  };
  index.value++;
  importComponent(item.componentName).then((component) => {
    item.component = markRaw(component);
    layout.value.push(item);
  });
};

const addItemDynamically = () => {
  let x, y;
  let found = false;
  for (let j = 0; !found && j < colNum.value * 10; j++) {
    for (let i = 0; i < colNum.value && !found; i++) {
      x = i;
      y = j;
      found = !layout.value.some(
        (item) =>
          item.x < x + 2 &&
          item.x + item.w > x &&
          item.y < y + 2 &&
          item.y + item.h > y
      );
      if (found) break;
    }
  }
  if (found) {
    let item = {
      x: x,
      y: y,
      w: 2,
      h: 2,
      i: index.value + "",
      componentName: "TestElement",
      data: { text: "动态添加项目" },
    };
    index.value++;
    importComponent(item.componentName).then((component) => {
      item.component = markRaw(component);
      layout.value.push(item);
      nextTick(() => {
        gridlayout.value.layoutUpdate();
      });
    });
  } else {
    let maxY = Math.max(...layout.value.map((item) => item.y + item.h));
    let item = {
      x: 0,
      y: maxY,
      w: 2,
      h: 2,
      i: index.value + "",
      componentName: "TestElement",
      data: { text: "动态添加项目" },
    };
    index.value++;
    importComponent(item.componentName).then((component) => {
      item.component = markRaw(component);
      layout.value.push(item);
      nextTick(() => {
        gridlayout.value.layoutUpdate();
      });
    });
  }
};

const move = (i, newX, newY) => {
  console.log("移动 i=" + i + ", X=" + newX + ", Y=" + newY);
};

const resize = (i, newH, newW, newHPx, newWPx) => {
  console.log(
    "调整大小 i=" +
      i +
      ", H=" +
      newH +
      ", W=" +
      newW +
      ", H(px)=" +
      newHPx +
      ", W(px)=" +
      newWPx
  );
};

const moved = (i, newX, newY) => {
  console.log("### 已移动 i=" + i + ", X=" + newX + ", Y=" + newY);
};

const resized = (i, newH, newW, newHPx, newWPx) => {
  console.log(
    "### 已调整大小 i=" +
      i +
      ", H=" +
      newH +
      ", W=" +
      newW +
      ", H(px)=" +
      newHPx +
      ", W(px)=" +
      newWPx
  );
};

const containerResized = (i, newH, newW, newHPx, newWPx) => {
  console.log(
    "### 容器已调整大小 i=" +
      i +
      ", H=" +
      newH +
      ", W=" +
      newW +
      ", H(px)=" +
      newHPx +
      ", W(px)=" +
      newWPx
  );
};

const layoutCreatedEvent = (newLayout) => {
  console.log("创建布局: ", newLayout);
};

const layoutBeforeMountEvent = (newLayout) => {
  console.log("挂载前布局: ", newLayout);
};

const layoutMountedEvent = (newLayout) => {
  console.log("已挂载布局: ", newLayout);
};

const layoutReadyEvent = (newLayout) => {
  console.log("布局就绪: ", newLayout);
  layout.value = newLayout;
};

const layoutUpdatedEvent = async (newLayout) => {
  console.log("更新布局: ", newLayout);
  layout.value = newLayout;
  // 保存布局数据
  await saveLayoutData(layout.value);
};

const breakpointChangedEvent = (newBreakpoint, newLayout) => {
  console.log("断点改变 breakpoint=", newBreakpoint, ", 布局: ", newLayout);
};

const toggleEditMode = () => {
  editMode.value = !editMode.value;
};

const dragstart = (e) => {
  e.dataTransfer.setData("text", "可拖放元素");
};

const drag = () => {
  const layoutUnref = layout.value;
  let parentRect = document.getElementById("content").getBoundingClientRect();
  let mouseInGrid = false;
  if (
    mouseXY.x > parentRect.left &&
    mouseXY.x < parentRect.right &&
    mouseXY.y > parentRect.top &&
    mouseXY.y < parentRect.bottom
  ) {
    mouseInGrid = true;
  }
  if (
    mouseInGrid === true &&
    layoutUnref.findIndex((item) => item.i === "drop") === -1
  ) {
    layoutUnref.push({
      x: (layoutUnref.length * 2) % (colNum.value || 12),
      y: Math.floor(layoutUnref.length / (colNum.value || 12)),
      w: 2,
      h: 2,
      i: "drop",
    });
  }
  let idx = layoutUnref.findIndex((item) => item.i === "drop");
  if (idx !== -1) {
    try {
      gridItemRefs.value.style.display = "none";
    } catch {}
    let el = gridItemRefs.value[idx];
    if (mouseInGrid === true && el) {
      el.dragging = {
        top: mouseXY.y - parentRect.top,
        left: mouseXY.x - parentRect.left,
      };
      let new_pos = el.calcXY(
        mouseXY.y - parentRect.top,
        mouseXY.x - parentRect.left
      );
      if (gridlayout.value) {
        gridlayout.value.dragEvent(
          "dragstart",
          "drop",
          new_pos.x,
          new_pos.y,
          2,
          2
        );
      }
      DragPos.i = String(idx);
      DragPos.x = layoutUnref[idx].x;
      DragPos.y = layoutUnref[idx].y;
    }
    if (mouseInGrid === false) {
      if (gridlayout.value) {
        gridlayout.value.dragEvent("dragend", "drop", 1, 1, 1, 1);
      }
      layout.value = layoutUnref.filter((obj) => obj.i !== "drop");
    }
  }
};

const dragend = () => {
  const layoutUnref = layout.value;
  let parentRect = document.getElementById("content").getBoundingClientRect();
  let mouseInGrid = false;
  if (
    mouseXY.x > parentRect.left &&
    mouseXY.x < parentRect.right &&
    mouseXY.y > parentRect.top &&
    mouseXY.y < parentRect.bottom
  ) {
    mouseInGrid = true;
  }
  if (mouseInGrid === true) {
    if (gridlayout.value) {
      gridlayout.value.dragEvent("dragend", "drop", DragPos.x, DragPos.y, 1, 1);
    }
    layout.value = layoutUnref.filter((obj) => obj.i !== "drop");
    layout.value.push({
      x: DragPos.x,
      y: DragPos.y,
      w: 2,
      h: 2,
      i: `new-${index.value}`,
      component: markRaw(importComponent("TestElement")),
      data: { text: "新项目" },
    });
    index.value++;
    console.log(layout.value);
  }
};
</script>

<style scoped>
/* Root Styles */
#app {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f5f5f5;
  padding-bottom: 50px;
  position: relative;
  min-height: 100vh;
}

/* Title */
.title {
  text-align: center;
  margin-top: 80px;
  color: #333;
}

/* Top Buttons */
.top-buttons {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background-color: #2c3e50;
  padding: 10px 20px;
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  z-index: 1000;
}

.top-buttons button {
  background-color: #ecf0f1;
  border: none;
  padding: 8px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.top-buttons button:hover {
  background-color: #bdc3c7;
}

/* Layout JSON Display */
.layoutJSON {
  background: #fff;
  border: 1px solid #ddd;
  margin: 20px auto;
  padding: 20px;
  width: 90%;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.layoutJSON h2 {
  margin-bottom: 10px;
  color: #555;
}

.columns {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.layoutItem {
  background-color: #e1e1e1;
  padding: 10px;
  border-radius: 4px;
  flex: 1 1 120px;
  text-align: center;
}

/* Content Area */
#content {
  width: 90%;
  margin: 20px auto;
  background: #fff;
  padding: 20px;
  border-radius: 8px;
  transition: background-color 0.3s ease;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#content.view-mode {
  background-color: #fafafa;
}

/* Control Buttons */
.control-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

.control-buttons button {
  background-color: #3498db;
  color: #fff;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.control-buttons button:hover {
  background-color: #2980b9;
}

.control-buttons label {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 14px;
  color: #333;
}

/* Grid Settings */
.grid-settings {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 20px;
}

.grid-settings label {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 14px;
  color: #333;
}

/* Grid Layout */
.vue-grid-layout {
  background: #f0f0f0;
  border: 1px dashed #ccc;
  padding: 10px;
  border-radius: 8px;
  min-height: 300px;
}

.vue-grid-layout.view-mode {
  background: #fafafa;
  border: none;
}

.vue-grid-item {
  background: #3498db;
  border: 1px solid #2980b9;
  border-radius: 4px;
  overflow: hidden;
  transition: background-color 0.3s ease;
}

.vue-grid-item.view-mode {
  background: #ecf0f1;
  border: 1px solid #bdc3c7;
}

.grid-component {
  position: absolute;
  height: 100%;
  width: 100%;
  top: 0;
  left: 0;
}

/* Draggable Element */
.droppable-element {
  width: 150px;
  text-align: center;
  background: #e67e22;
  color: #fff;
  border: none;
  margin: 10px 0;
  padding: 10px;
  border-radius: 4px;
  cursor: grab;
  transition: background-color 0.3s ease;
}

.droppable-element:hover {
  background: #d35400;
}

/* Edit Mode Overlay */
.edit-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(44, 62, 80, 0.8);
  z-index: 999;
  display: flex;
  align-items: center;
  justify-content: center;
}

.overlay-button {
  background-color: #ecf0f1;
  color: #2c3e50;
  border: none;
  padding: 15px 25px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 18px;
  transition: background-color 0.3s ease;
}

.overlay-button:hover {
  background-color: #bdc3c7;
}
</style>
